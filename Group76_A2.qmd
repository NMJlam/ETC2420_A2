---
title: "ETC2420/5242 Assignment 2"
subtitle: "Group [X] - [Your Group Name]"
author: 
  - "Student Name 1 (Student ID)"
  - "Student Name 2 (Student ID)"
  - "Student Name 3 (Student ID)"
  - "Student Name 4 (Student ID)"
date: "13 October 2025"
format:
  pdf:
    toc: true
    toc-depth: 2
    number-sections: true
    colorlinks: true
    geometry:
      - margin=2.5cm
    fontsize: 11pt
execute:
  echo: true
  warning: false
  message: false
  eval: true
---

# Initial Setup

```{r setup}
# Load required libraries
library(tidyverse)
library(gridExtra) 
library(broom)      
library(dplyr)
library(ggplot2)

# Set seed for reproducibility
set.seed(24205242)  # Use your student ID

# Set knitr options
knitr::opts_chunk$set(echo = TRUE, warning = FALSE,
                      eval = TRUE, message = FALSE)

# Read data (adjust path as needed)
pedestrians <- read.csv("data/pedestrians.csv")
# Verify that the data exists 
```

\newpage

# Task 1: \[20 Marks\]

## Description

Your manager wants to understand the distribution of the number of people using the three pedestrian crossings. She would like some appropriate descriptive and visual summaries of the data. In addition, she would like fitted models for each crossing, which she wants to share with the engineering team to help with planning and design.

Required analyses and components:

-   One or more appropriate plots to visualize the data.

-   Some appropriate descriptive statistics.

-   Fit appropriate models to the data, and report the resulting estimates.

-   Assess the adequacy of the model fits, using appropriate statistical techniques.

## Requirement 1: Plots to visualize the data

**Data preparation**

```{r task1-data-prep}
ped_long <- pedestrians |>
  pivot_longer(cols = everything(),
               names_to = "location",
               values_to = "count")
```

**Requirement 1.1: Histogram:**

A histogram is used to show the shape of the traffic distribution at each crossing. This allows us to summarize the distribution of the foot traffic at each section.

[Creating a function to plot the graphs using a histogram.]{.underline}

```{r task1-plots}
# Requirement 1: Plot histograms/density for each location
plot_3_histograms <- function(long_data, binwidth = 50) {
  ggplot(long_data, aes(x = count)) +
    geom_histogram(binwidth = binwidth, fill = "skyblue", colour = "black") +
    facet_wrap(~ location, scales = "free") +
    labs(title = "Distribution of pedestrian counts",
         x = "Pedestrian count per hour", y = "Frequency")
}
```

[Display the histograms]{.underline}

```{r task 1 plots}
plot_3_histograms(ped_long)
```

**Requirement 1.2: Box-Whisker Plot**

A box-whisker plot is used to display the central tendency of the how the foot traffic is being spread

[Creating a function to plot the graphs in a box-whisker plot]{.underline}

```{r}
plot_boxplots <- function(long_data) {
  long_data |>
    mutate(location = forcats::fct_relevel(location, sort(unique(location)))) |>
    ggplot(aes(x = location, y = count, fill = location)) +
    geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2) +
    labs(title = "Pedestrian counts by location",
         x = "Location", y = "Pedestrian count per hour") +
    theme_minimal() + theme(legend.position = "none")
}
```

[Display the box-whisker plots.]{.underline}

```{r}
plot_boxplots(ped_long)
```

## Requirement 2: Appropriate Summary Statistics

```{R task1-summary statistics}
# Requirement 2: Appropriate summary statistics
get_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

ped_descriptive <- ped_long |>
  group_by(location) |>
  summarise(
    mean = mean(count),
    median = median(count),
    mode = get_mode(count),
    sd = sd(count),
    min = min(count),
    max = max(count),
    q1 = quantile(count, 0.25),
    q3 = quantile(count, 0.75)
  )

ped_descriptive
```

## Requirement 3: Fit appropriate models to the data, and report the resulting estimates.

```{r data-preparation}
qv_melbourne_traffic <- pedestrians[["qv_melbourne"]]
southern_cross_traffic <- pedestrians[["southern_cross"]]
flinders_street_traffic <- pedestrians[["flinders_street"]]
```

1)  Choose a model for the data

Flinders_street: mean = median Southern Cross: mean = median qv: slight right skew

2)  "Fit" the model

```{r fit-model}
fit_flinders_norm <- fitdistr(flinders_street_traffic, "normal")
fit_southern_norm <- fitdistr(southern_cross_traffic,   "normal")
fit_qv_gamma      <- fitdistr(qv_melbourne_traffic,     "gamma")

estimates <- tibble(
  location = c("flinders_street", "southern_cross", "qv_melbourne"),
  model    = c("Normal", "Normal", "Gamma"),
  par1     = c(fit_flinders_norm$estimate["mean"],
               fit_southern_norm$estimate["mean"],
               fit_qv_gamma$estimate["shape"]),
  par2     = c(fit_flinders_norm$estimate["sd"],
               fit_southern_norm$estimate["sd"],
               fit_qv_gamma$estimate["rate"])
)
estimates
```

## Requirement 4: Assess the adequacy of the model fits, using appropriate statistical techniques.

```{r}
# Flinders (Normal QQ)
ggplot(tibble(x = flinders_street_traffic), aes(sample = x)) +
  stat_qq(distribution = qnorm,
          dparams = list(mean = fit_flinders_norm$estimate["mean"],
                         sd   = fit_flinders_norm$estimate["sd"])) +
  stat_qq_line(distribution = qnorm,
               dparams = list(mean = fit_flinders_norm$estimate["mean"],
                              sd   = fit_flinders_norm$estimate["sd"])) +
  labs(title = "Flinders Street: Normal QQ plot")

# Southern Cross (Normal QQ)
ggplot(tibble(x = southern_cross_traffic), aes(sample = x)) +
  stat_qq(distribution = qnorm,
          dparams = list(mean = fit_southern_norm$estimate["mean"],
                         sd   = fit_southern_norm$estimate["sd"])) +
  stat_qq_line(distribution = qnorm,
               dparams = list(mean = fit_southern_norm$estimate["mean"],
                              sd   = fit_southern_norm$estimate["sd"])) +
  labs(title = "Southern Cross: Normal QQ plot")

# QV (Gamma QQ)
ggplot(tibble(x = qv_melbourne_traffic), aes(sample = x)) +
  stat_qq(distribution = qgamma,
          dparams = list(shape = fit_qv_gamma$estimate["shape"],
                         rate  = fit_qv_gamma$estimate["rate"])) +
  stat_qq_line(distribution = qgamma,
               dparams = list(shape = fit_qv_gamma$estimate["shape"],
                              rate  = fit_qv_gamma$estimate["rate"])) +
  labs(title = "QV Melbourne: Gamma QQ plot")
```

# Task 2: \[20 marks\]

## Introduction

The task is to calculate the 90th percentile of the amount of traffic in each of the crossings (Southern Cross, Flinder's Street, QV Melbourne)

## Data Preparation

```{r task2-data-prep}
# Get each of the locations
qv_melbourne_traffic <- pedestrians[["qv_melbourne"]]
southern_cross_traffic <- pedestrians[["southern_cross"]]
flinders_street_traffic <- pedestrians[["flinders_street"]]
```

### Technical Approach

**Approach 1: Non-parametric Quantile Method**

This involves bootstrapping, where many re-samples of the original data are created (with replacement) to emulate the variability we would see if we could repeatedly sample from the real population.

For each bootstrap sample, we calculate the 90th percentileâ€”the value below which 90% of the observations in that specific sample fall. We repeat this process thousands of times, accumulating all of these 90th percentile values to create a distribution of the 90th percentile estimator.

We then find the 2.5th and 97.5th percentiles of this bootstrap distribution to construct a 95% confidence interval. This interval provides our estimate of the true population 90th percentile with 95% confidence, allowing us to determine the traffic level that each crossing must accommodate to ensure smooth pedestrian flow 90% of the time.

```{r task2-analysis}
# Approach 1: Sample (Empirical) Quantile Method
find_90th_percentile <- function(data, trials = 5000) {
  # Ensure data is a numeric vector
  if (!is.numeric(data)) {
    stop("Input must be a numeric vector.")
  }
  
  # Remove missing values
  x <- data[!is.na(data)]
  n <- length(x)
  if (n == 0) stop("No data points available after removing NA.")
  
  # Bootstrap resamples
  q_boot <- replicate(trials, {
    xb <- sample(x, size = n, replace = TRUE)
    as.numeric(quantile(xb, probs = 0.9, type = 7))
  })
  
  # 95% CI from bootstrap distribution
  ci <- quantile(q_boot, probs = c(0.025, 0.975))
  
  result <- list(
    ci_lower = unname(ci[1]),
    ci_upper = unname(ci[2])
  )
  
  return(result)
}
```

**Approach 2: Parametric Quantile method**

```{r}
find_90thPercentile_normal <- function(data, trials = 5000) {
  x <- as.numeric(data)
  x <- x[is.finite(x)]
  n <- length(x)
  if (n < 2) stop("Need at least 2 observations.")

  # 1. Fit Normal model by MLE
  mu_hat <- mean(x)
  sigma_hat <- sqrt(mean((x - mu_hat)^2))  # MLE version, divides by n

  # 2. Point estimate of the 90th percentile
  q90_hat <- qnorm(0.90, mean = mu_hat, sd = sigma_hat)

  # 3. Parametric bootstrap for 95% CI
  q_boot <- replicate(trials, {
    # simulate new sample from fitted Normal
    xb <- rnorm(n, mean = mu_hat, sd = sigma_hat)
    # re-fit Normal on xb
    mu_b <- mean(xb)
    sd_b <- sqrt(mean((xb - mu_b)^2))
    # compute q90 for this bootstrap sample
    qnorm(0.90, mean = mu_b, sd = sd_b)
  })

  # CI = central 95% of bootstrap distribution
  ci <- quantile(q_boot, c(0.025, 0.975), names = FALSE)

  # Return point estimate + CI
  list(
    ci_lower = ci[1],
    ci_upper = ci[2]
  )
}

find_90thPercentile_gamma <- function(data, trials = 5000) {
  x <- as.numeric(data)
  x <- x[is.finite(x)]
  n <- length(x)
  if (n < 2) stop("Need at least 2 observations.")
  if (any(x <= 0)) stop("Gamma model requires strictly positive data.")

  # 1. Fit Gamma model by MLE
  # Requires MASS::fitdistr (Week 6 lecture)
  fit <- MASS::fitdistr(x, densfun = "gamma")
  shape_hat <- unname(fit$estimate["shape"])
  rate_hat  <- unname(fit$estimate["rate"])

  # 2. Point estimate of the 90th percentile
  q90_hat <- qgamma(0.90, shape = shape_hat, rate = rate_hat)

  # 3. Parametric bootstrap for 95% CI
  q_boot <- replicate(trials, {
    # simulate new sample from fitted Gamma
    xb <- rgamma(n, shape = shape_hat, rate = rate_hat)
    # re-fit Gamma on xb
    fit_b <- MASS::fitdistr(xb, densfun = "gamma")
    sh_b <- unname(fit_b$estimate["shape"])
    rt_b <- unname(fit_b$estimate["rate"])
    # compute q90 for this bootstrap sample
    qgamma(0.90, shape = sh_b, rate = rt_b)
  })

  # CI = central 95% of bootstrap distribution
  ci <- quantile(q_boot, c(0.025, 0.975), names = FALSE)

  # Return point estimate + CI
  list(
    ci_lower = ci[1],
    ci_upper = ci[2]
  )
}
```

### Results

```{r task2-results}
# Approach 1: Sample (Empirical) Quantile Method
qv_estimate_bootstrap <- find_90th_percentile(qv_melbourne_traffic)
flinders_estimate_bootstrap <- find_90th_percentile(flinders_street_traffic)
southern_estimate_bootstrap <- find_90th_percentile(southern_cross_traffic)

# Approach 2: Model Based Quantile
qv_estimate_gamma <- find_90thPercentile_gamma(qv_melbourne_traffic)

flinders_estimate_normal <- find_90thPercentile_normal(flinders_street_traffic)
southern_estimate_normal <- find_90thPercentile_normal(southern_cross_traffic)
```

<!-- Technical interpretation of results -->

## Interpretation

<!-- Non-technical explanation for a general audience -->

## Conclusions and Recommendations

<!-- Evidence-based conclusions for Task 2 -->

\newpage

# Task 3: \[Task Title\]

## Introduction

<!-- Overview of Task 3 -->

welch

## Methodology

### Data Processing

```{r task3-data}
# Data processing code

```

### Statistical Methods

<!-- Explain the statistical techniques used -->

```{r task3-methods}
# Implementation of statistical methods

```

## Results and Visualizations

```{r task3-plots}
# Create visualizations

```

**Figure 3.1:** \[Caption\]

### Technical Analysis

<!-- Technical interpretation -->

### Non-Technical Summary

<!-- Explain findings in accessible language -->

## Conclusions and Recommendations

<!-- Evidence-based conclusions for Task 3 -->

\newpage

# Task 4: \[Task Title\]

## Introduction

<!-- Overview of Task 4 -->

## Analysis Approach

### Data Exploration

```{r task4-exploration}
# Exploratory analysis

```

### Statistical Analysis

<!-- Describe your analytical approach -->

```{r task4-analysis}
# Main analysis code

```

## Results

```{r task4-results}
# Results and visualizations

```

**Figure 4.1:** \[Caption\]

### Technical Findings

<!-- Technical interpretation of results -->

### Practical Implications

<!-- Non-technical explanation and real-world implications -->

## Conclusions and Recommendations

<!-- Evidence-based conclusions for Task 4 -->

\newpage

# Task 5: \[Task Title\]

## Introduction

<!-- Overview of Task 5 -->

## Comprehensive Analysis

### Data Integration

```{r task5-data-integration}
# Combining and processing data

```

### Analytical Framework

<!-- Describe your comprehensive approach -->

```{r task5-framework}
# Implementation of analytical framework

```

## Results and Insights

```{r task5-results}
# Generate comprehensive results

```

**Figure 5.1:** \[Caption\]

### Technical Analysis

<!-- Detailed technical interpretation -->

### Business/Practical Interpretation

<!-- Non-technical explanation for decision-makers -->

## Final Conclusions and Recommendations

<!-- Overall evidence-based conclusions for Task 5 -->

\newpage

# Overall Summary and Conclusions

```{=html}
<!-- 
Provide a brief summary of key findings across all tasks.
Highlight the most important insights and recommendations.
-->
```

## Key Findings

<!-- Summarize main results from all tasks -->

## Limitations

<!-- Discuss any limitations of your analysis -->

## Future Directions

<!-- Suggest areas for further investigation -->

\newpage

# Appendix (Optional)

## Additional Code

```{r appendix-code}
# Any supplementary code that supports your analysis
# but is too detailed for the main sections

```

## Additional Tables and Figures

<!-- Include any supplementary materials here -->

\newpage

# References

```{=html}
<!-- 
If you use external sources, cite them appropriately.
You can use Quarto's citation features or list them manually.
-->
```

## Session Information

```{r session-info}
sessionInfo()
```

**Note:** This ensures reproducibility by documenting package versions used.
